# 集合进阶

## 单列集合

一次添加一个数据

最高级Collection接口

分为list系类和set系类

list接口下实现类

1. ArrayList
2. LinkedList
3. Vector(淘汰了)

set接口下实现类

1. Hashset      下有LinkedHashSet
2. TreeSet

List系类在添加元素的时候有序，可重复，有索引

有序指存和取的顺序一样，比如我存123，返回就是123而不会是321后两个好理解

set系类在添加元素的时候，无序，不重复，无索引

无序指存和取的顺序有可能不一样

### Collection

方法add，返回值布尔值

clear，清空，无返回值

remove删除给定的对象，返回布尔

contains判断集合是否包含当前对象，返回布尔

isEmpty判断集合是否为空，返回布尔

size，返回集合中元素的个数，返回值为个数int

也就是说，接下来的所有实现类，都会有这些方法

往list方向添加，永远是true，但是在set方法中添加元素，一旦出现重复，就会添加失败，返回false

collection的remove不能通过删除索引来删除，因为set方向没有索引，只能通过元素的对象进行删除，底层是依赖equals方法判断是否存在的，如果集合中存的是自定义对象，也想通过contains方法来判断，那么在Javabean中一定要重写equals方法，为什么呢，因为equals判断的是地址值，也就是student1，student2，而不是里面的属性，当我想要属性相同就判断是同一个学生时，equals方法就不能做到了，所以需要在自定义的javabean中重写equals方法，重写之后的equals判断的就是地址值了

### 遍历

普通for循环遍历在Set中并不适用，因为普通for循环利用的是索引来遍历，而Set类中没有索引

#### 迭代器遍历

不依赖索引，在Java中的类是Iterator，是集合专用的遍历方式

我们可以通过获取迭代器的对象Iterator<E> iterator()，***注意迭代器的获取不是new了而是通过方法的返回值来获取***返回迭代器对象，默认指向集合的零索引处

```java
Iterator<E> 迭代器名 = 迭代器对应的类.iterator()这个是方法
```

迭代器是从方法返回值里出来的这个很神奇

迭代器里的方法，要用迭代器对象来调用的常用方法

1. boolean hasNext判断当前位置是否有元素
2. E next()获取当前位置的元素，并将迭代器对象移向下一个位置

利用循环，以第一个方法为判断，第二个方法为内容，就可以遍历全部元素了

迭代器操作顺序要了解，是先输出这个对象，再移动指针，也就是说，当我们完成遍历时，指针已经指在了空，那么如果我们再输出这个空，得到的将不是数组下标越界，而是找不到元素，因为它不依赖索引，已经超标了

迭代器遍历完毕后指针不会复位，只能再来一个新的迭代器来完成迭代

***注意***：循环中只能有一个next方法，如果有两个next方法，一次移动两次指针，就可能造成过度移动指针导致报错，所以不能通过这种方式反复获取一个值，要反复获取一个值也很简单，我们只要用把这个next的值赋值给一个变量，然后用sout再输出一次这个变量，就不会造成多次使用方法了

用迭代器遍历时不能用集合的方法增加或删除元素，会直接报错，并发修改异常，ConcurrentModificationException，那我就要删除怎么办呢，迭代器还有一种方法，remove移除迭代器返回的最后一个元素（可选），我们配合if语句进行使用，就可以在当前情况下删除我们想删除的元素***（这个元素在目前是最后一个返回的）***，暂时没办法添加，暂时当作一个结论先行记忆，下一节会分析源码

#### 增强for遍历

增强for的底层就是迭代器，它的出现就是为了简化迭代器代码书写的，，所有的单列集合和数组才可以使用增强for来遍历

快捷，集合.for

细节：修改for循环中的变量，不会改变集合原本的数据，在for循环中定义的变量是一个新的第三方变量，它只负责记录，不传递地址，修改这个第三方变量对我们的数组不会造成影响

#### lambda表达式遍历

方法名称

default void forEach(Consumer<? super T>action):

要new一下这个接口创建匿名内部类

这个方法底层，是一个普通for来遍历索引的操作，这为什么会有索引，应该是方法创造的，利用elementAt方法来接收这个索引的每一个元素，然后把元素交给accept方法接收，方法底层会把得到的每一个元素传递给accept方法，所以s，就是我们得到的每一个数据，直接打印s就可以获得对应的数组元素

接下来是lambda表达式

()->{},小括号匹配重写方法的形参，大括号匹配方法体，剩余的内容直接删掉变成箭头

它还可以进一步简化，数据类型可以省略，参数只有一个，小括号可以省略，方法体只有一行，大括号可以省略，return可以省略，封号可以省略，最后结果直接炸裂

```java
list.forEach(s -> System.out.println(s));
```

![](C:\Users\余思衡\Desktop\Markdown学习\图片保存处\屏幕截图 2023-10-09 154333.png)

（前面输出的话忘记写了）本来是长这样，删改后长这样，我们要大括号中的方法体，要形参，forEach留下，其他改成->,改完后，形参类型可以省略，只有一个形参小括号可以省略，方法体只有一句话大括号可以省略，最后留下的就是这些

![](C:\Users\余思衡\Desktop\Markdown学习\图片保存处\屏幕截图 2023-10-09 154847.png)

## 总结

在遍历过程中要删除元素可以使用迭代器，不要删除可以直接使用增强for循环或者lambda表达式
