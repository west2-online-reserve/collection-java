# 1 解题思路

## 1.1 从官网上爬取所需的Json数据文件

![数据](/Users/caiqiyang/Pictures/数据.png)

## 1.2 解析数据的JSON文件结构并找出所需数据

### 1.2.1 athlete.json文件主要结构

![Althelete](/Users/caiqiyang/Pictures/altheletes结构.png)

### 1.2.2 每轮次比赛结果数据JSON文件结构

![结果结构](/Users/caiqiyang/Pictures/Result结构.png)

## 1.3 根据所需数据编写JSON映射类提取所需数据

根据上面的文件结构图，可以得知我们如果要提取运动员信息需要先编写一个country辅助类来映射CountryName和Participaitons信息，由于Participations下还有次级结构，所以还需要编写一个Participations映射类来映射Participations下所包含的数据。同理可编写提取比赛结果的JSON映射类。

## 1.4 编写Player和Result类

- Player类表示一个运动员

- Result类表示一个运动员参加一个比赛所有轮次成绩

  使用Player和Resut类创建List来存储数据

## 1.5 编写主函数来处理Input.txt中的指令

- 逐行读取文件中的指令
- 处理指令并根据指令匹配相应操作
- 将处理好的结果写入Output.txt

---

# 2 CoreModule设计和实现过程

## 2.1 代码组织

### 2.1.1 核心接口

``` java
//生成运动员信息并返回
public String playerInfo() 
  
//生成决赛信息并返回
public String finalResults(String dataPath)
  
//生成每一轮次详细信息返回
public String detailedResults(String dataPath) 
```

### 2.1.2 辅助方法

``` java
//将单跳得分列表拼接为 "得分 1 + 得分 2 + ... = 总分" 格式		
createScoresString(List<Double> scores, double totalScore)	
  
//将各阶段排名拼接为 " 初赛排名 | 半决赛排名 | 决赛排名 " 格式
createRankString(Result result)	
 
//将单跳得分字符串转换为 Double 列表，异常值默认设为 0.0		
parseDiveScores(List<Dive> dives)	
 
//统一双人项目姓名格式（按姓氏字母排序，用 "&" 连接）		
sortDoublesName(String name)	

```

### 2.1.3 数据模型类

- **Player**：封装运动员基本信息（姓名、性别、国家），提供只读访问接口。
- **Result**：封装单个运动员的全阶段比赛成绩（各轮次排名、单跳得分、总分），支持排名和得分的更新。

### 2.1.4 JSON映射类

- **Country**：映射 `athletes.json` 中的国家信息（国家名称、运动员列表）。
- **Participations**：映射 `athletes.json` 中的运动员参赛信息（性别、姓名、参赛项目）。
- **Discipline**：映射比赛成绩 JSON 中的项目信息（项目名称、轮次列表）。
- **Heat**：映射比赛成绩 JSON 中的轮次信息（轮次名称、选手成绩列表）。
- **ResultData**：映射比赛成绩 JSON 中的选手单轮成绩（姓名、排名、单跳详情、总分）。
- **Dive**：映射比赛成绩 JSON 中的单跳信息（单跳得分）。

## 2.2 核心接口实现

**(1). playerInfo( ) 实现流程**

1. 模块初始化时，调用 `extractPlayers()` 方法解析 `athletes.json`。
2. 遍历 JSON 中的国家列表，提取每个国家的运动员信息。
3. 转换性别编码（0→Male，1→Female），拼接姓名格式（姓氏 + 名字）。
4. 创建 `Player` 对象并加入列表，最终通过 `StringBuilder` 组装成结构化字符串返回。

**(2). finalResults(String dataPath) 实现流程**

1. 调用 `extractCompetitionResults(dataPath)` 解析指定比赛成绩文件。
2. 遍历文件中的轮次信息，筛选出决赛（Finals）阶段数据。
3. 提取选手姓名（统一双人项目姓名排序格式）、排名、单跳得分和总分。
4. 通过 `createScoresString()` 拼接单跳得分与总分，组装成决赛成绩字符串返回。

**(3). detailedResults(String dataPath) 实现流程**

1. 同 `finalResults()` 第一步，解析指定比赛成绩文件。
2. 遍历所有轮次（初赛 / 半决赛 / 决赛），收集选手各阶段的排名、得分数据。
3. 通过 `createRankString()` 拼接各阶段排名，`createScoresString()` 拼接各阶段得分。
4. 组装成包含全阶段信息的详细成绩字符串返回。

# 3 算法独特之处与性能改进

1. 使用StringBuilder创建结果字符串，一次性写入Output.txt中，减少I/O操作次数，提高程序运行速度。
2. 在`extractCompetitionResults(dataPath)`中使用了HashMap来检查是否已经存在该运动员比赛结果对象，避免重复创建Result对象，将查找速度降至O(1)。
3. 预估了结果的大概字符数量，在创建StringBuilder时预先为其分配略大于预估值的初始容量，避免在append过程中频繁的扩容操作增加的不必要的开销。

# 4 单元测试（代码大部分参考了AI）

## 4.1 概述

CoreModuleTest是针对 CoreModule 类的单元测试集合，使用 JUnit 5 框架编写。其核心目标是验证 CoreModule 所有公开方法的功能正确性、边界条件处理能力和异常鲁棒性，确保该类在各种输入场景下都能返回符合预期的结果。

## 4.2 测试用例设计

测试用例覆盖了 CoreModule 的三大核心功能模块：**运动员信息提取**、**比赛成绩提取（决赛 / 详细）**、**异常与边界场景处理**，共设计 8 个测试用例，确保覆盖主要业务逻辑和潜在风险点。

### 4.2.1 运动员信息提取测试

|             测试用例              |        测试目标        |                    输入 / 场景                     |                           预期结果                           |                          合理性说明                          |
| :-------------------------------: | :--------------------: | :------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     `testPlayerInfo_NotEmpty`     | 验证运动员信息列表非空 |    加载默认的 `athletes.json`（测试资源目录下）    | 返回的信息字符串包含 `Full Name:`、`Gender:`、`Country:` 关键字，且非空 | 确保 `extractPlayers()` 方法能成功解析 JSON 文件并初始化运动员列表，是后续所有功能的基础 |
| `testPlayerInfo_GenderConversion` | 验证性别编码转换正确性 | `athletes.json` 中包含性别编码 0 和 1 的运动员数据 |   返回的信息中性别仅为 `Male` 或 `Female`，无原始数字编码    |      覆盖性别转换的核心业务规则，避免编码泄露到最终结果      |

### 4.2.2 比赛成绩提取测试

|             测试用例             |                   测试目标                   |                         输入 / 场景                          |                           预期结果                           |                          合理性说明                          |
| :------------------------------: | :------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   `testFinalResults_ValidData`   |           验证决赛成绩解析与格式化           | 动态生成包含完整决赛数据的 JSON（1 名运动员，5 次跳水得分，排名 1，总分 500.00） | 结果包含运动员姓名、排名 1、得分拼接字符串 `100.0 + 100.0 + ... = 500.00` | 覆盖决赛成绩提取的核心流程（文件解析、得分累加、排名映射），验证正常业务场景的正确性 |
| `testFinalResults_NoFinalsPhase` |          验证无决赛轮次时的结果处理          |                 动态生成仅含初赛数据的 JSON                  |            决赛排名显示为 `*`，决赛得分显示为 `*`            | 覆盖 “运动员未进入决赛” 的边界场景，确保缺省数据的格式化符合预期 |
| `testDetailedResults_AllPhases`  | 验证多轮次成绩（初赛 / 半决赛 / 决赛）的整合 |               动态生成包含三个轮次成绩的 JSON                |                    结果正确拼接各轮次排名                    | 覆盖最复杂功能的验证 `extractCompetitionResults()` 对多阶段数据的关联能力 |

### 4.2.3 异常与边界测试

|                   测试用例                   |           测试目标           |                         输入 / 场景                          |         预期结果         |                          合理性说明                          |
| :------------------------------------------: | :--------------------------: | :----------------------------------------------------------: | :----------------------: | :----------------------------------------------------------: |
| `testExtractCompetitionResults_FileNotFound` |  验证文件不存在时的异常处理  |                   传入不存在的 JSON 文件名                   |   返回空字符串，无崩溃   |   覆盖文件路径错误、文件缺失等常见异常场景，确保程序鲁棒性   |
| `testExtractCompetitionResults_InvalidJson`  | 验证无效 JSON 格式的异常处理 | 动态生成包含非 JSON 内容的文件（如 `this is not a valid json`） |   返回空字符串，无崩溃   | 覆盖文件损坏、格式错误等异常场景，确保 `Gson` 解析失败时程序能正常容错 |
|      `testDetailedResults_EmptyResults`      |  验证无选手成绩时的结果处理  |             动态生成 JSON 中 `Results` 列表为空              | 返回空字符串，无多余内容 | 覆盖 “比赛无选手参与” 的极端边界场景，确保空数据处理不产生垃圾输出 |

# 5 异常处理说明

## 5.1 `DWASearch` 异常处理说明

### 5.1.1 命令行参数校验

- **触发条件**：用户输入的命令行参数数量不为 2（未提供输入 / 输出文件路径/参数多余）。
- **处理逻辑**：
  1. 通过 `System.err` 输出标准化用法提示（`用法：java -jar DWASearch.jar <输入文件路径> <输出文件路径>`）；
  2. 调用 `System.exit(1)` 终止程序，退出码为 1。

### 5.1.2 文件操作异常

- **覆盖场景**：
  - 输入文件不存在；
  - 无文件读写权限；
  - 文件路径非法（如目录不存在、文件名含特殊字符）；
  - 文件读取 / 写入过程中断（如文件损坏、磁盘空间不足）。
- **处理逻辑**：
  1. 统一捕获 `IOException` 及其子类（文件操作相关异常的父类）；
  2. 通过 `System.err` 输出具体错误信息（如 `文件操作错误：系统找不到指定的文件`）；
  3. 不终止程序（仅打印错误），但后续流程因流初始化失败而自然终止。
- **资源安全保障**：
  - 流对象（`reader`、`writer`）在 `try` 外部声明，`finally` 块中强制关闭（即使中间流程抛出异常）；
  - 关闭流时再次捕获 `IOException`（避免因流关闭失败导致程序崩溃）。

### 5.1.3 输入文件内容异常

- **场景 1：输入文件为空**
  - 触发条件：`reader.readLine()` 读取第一行为 `null`（文件无任何内容）。
  - 处理逻辑：向输出文件写入 `Error\n-----\n`。
- **场景 2：空行命令**
  - 触发条件：读取的命令行经过 `trim()` 后为空字符串（用户输入空行）。
  - 处理逻辑：向输出文件写入 `Error\n-----\n`，跳过当前空行，继续处理下一行。

### 5.1.4 命令格式异常

- **场景 1：未知命令**
  - 触发条件：命令的第一个关键字既不是 `players` 也不是 `result`。
  - 处理逻辑：向输出文件写入 `Error\n-----\n`，继续处理下一行命令。
- **场景 2：`players` 命令参数错误**
  - 触发条件：`players` 命令后跟随多余参数。
  - 处理逻辑：向输出文件写入 `Error\n-----\n`，继续处理下一行命令。
- **场景 3：`result` 命令参数错误**
  - 触发条件：
    1. 参数长度不为 4 或 5（如 `result men 10m` 缺少参数，`result women 3m sync detail extra` 多余参数）；
    2. 当参数长度为 5 时，最后一个参数不是 `detail`（如 `result men 10m platform info`）。
  - 处理逻辑：向输出文件写入 `N/A\n-----\n`，继续处理下一行命令。

### 5.1.5 文件名称映射异常

- **触发条件**：`result` 命令中的项目名称无法匹配到预定义的 JSON 数据文件（如 `result men 5m platform`、`result women 3m spring`）。
- **处理逻辑**：
  1. `mapCommandToData()` 方法返回 `null`；
  2. 向输出文件写入 `N/A\n-----\n`，继续处理下一行命令。

## 5.2 `CoreModule` 异常处理说明

### 5.2.1 资源加载异常

- **覆盖场景：**
  - 核心数据文件（`athletes.json`、比赛成绩 JSON 文件）未在 classpath 中找到；
  - 数据文件读取权限不足；
  - 流初始化失败（如文件损坏、I/O 中断）。

- 处理逻辑
  - **`extractPlayers()` 方法**（加载运动员信息）：
    1. 使用 `try-with-resources` 自动管理流资源，确保异常时资源正常关闭；
    2. 统一捕获 `Exception`（覆盖所有可能的 I/O 异常、JSON 解析异常）；
    3. 异常时打印堆栈信息，但不中断程序（`players` 列表保持空，后续调用 `playerInfo()` 会返回空字符串，避免崩溃）。
  - **`extractCompetitionResults()` 方法**（加载比赛成绩）：
    1. 同样使用 `try-with-resources` 管理流资源；
    2. 捕获 `Exception` 后，打印堆栈信息并输出提示 `No such file or directory`；
    3. 关键处理：调用 `competitionResults.clear()` 重置结果列表，避免上一次残留数据影响，确保后续调用返回干净结果。

### 5.2.2 JSON 解析异常

- **覆盖场景：**
  - JSON 文件格式非法（如缺少闭合括号、键值对格式错误）；
  - JSON 数据与映射类（`Country`、`Discipline` 等）字段不匹配；
  - 数据类型转换失败（如 JSON 中数字字段为字符串格式）。

- **处理逻辑：**
  - 由 `Gson.fromJson()` 方法抛出 异常，最终被上层 `try-catch` 块捕获；
  - 处理方式与 “资源加载异常” 一致：打印堆栈信息、重置结果列表，确保程序继续运行。

### 5.2.3 数据转换异常

- **场景 1：得分解析异常（`parseDiveScores()` 方法）**
  - **触发条件**：`DivePoints` 字段非数字格式（如 `"abc"`、空字符串），导致 `Double.parseDouble()` 抛出 `NumberFormatException`。
  - **处理逻辑**：
    1. 捕获异常后，将该次跳水得分默认设为 `0.0`；
    2. 不中断循环，继续解析后续跳水得分，确保单个数据错误不影响整体结果。

- **场景 2：双人姓名排序异常（`sortDoublesName()` 方法）**
  - **触发条件**：姓名格式非法（如 `&` 分隔符数量异常、姓名部分为 `null`）。
  - **处理逻辑**：
    1. 仅当姓名包含且仅包含一个 `&` 时才进行排序，否则直接返回原始姓名（或空字符串，若姓名为 `null`）；
    2. 排序时通过 `Comparator.comparing()` 处理姓名拆分，避免 `ArrayIndexOutOfBoundsException`（拆分后无姓氏时返回完整姓名）。

### 5.2.4 边界异常处理

- **场景 1：空数据处理（`createScoresString()` 方法）**
  - **触发条件**：`scores` 列表为空（如运动员未参与某轮次比赛）。
  - **处理逻辑**：返回 `*` 字符串，明确标识该轮次无得分数据。

- **场景 2：排名缺省处理（`createRankString()` 方法）**
  - **触发条件**：某轮次排名为 `-1`（初始化默认值，表示未参与该轮次）。
  - **处理逻辑**：将排名显示为 `*`。

