



## 定时任务发展历程

### 1、Windows批处理程序

我们在平时的工作中即可使用windows的批处理执行定时任务，比如下列的一个例子：

在cmd中输入 `shutdown -s -f -t 666`, 即可在666秒后自动关闭电脑 （或在.bat文件中输入这行命令并打开文件即可）

### 2、Windows任务计划程序

在计算机管理页面，找到任务计划程序，可以在这里导入或创建基本定时任务

### 3、Linux命令 - CronJob

Cron命令在Linux中十分重要，Cron表达式也基本上是每个开发者必学的知识之一。在Linux中我们可以很轻易的使用简单的Cron表达式创建定时任务。当然也有些优缺点

* 优点: CronJob是Linux系统命令，使用简单，稳定可靠
* 缺点: 只能控制单台机器，且无法适用于其他操作系统

### 4、单机定时任务

在开发语言中一般都会有Timer、Ticker这种存在，他的优点是可以跨平台支持(开发语言特性)，但是也是仅有单机可用

Examples:

#### Timer

~~~java
// 每隔五分钟定时刷新本地缓存
public static void main(String[] args) throws ParseException {
    Timer timer = new Timer();
    timer.schedule(new TimerTask() {
        @override
        public void run() {
            SyncLocalCache();
        }
    }, 5000, 5 * 60 * 1000);
}
~~~

#### Ticker

~~~go
// 每隔五分钟定时刷新本地缓存
func main() {
    ticker := time.newTicker(5 * time.Minute)
    for {
        select {
            case <- ticker.C:
            SyncLocalCache()
        }
    }
}
~~~

#### ScheduledExecutorService

~~~java
// 每隔五分钟定时执行多个任务
private static ScheduledExecutorServcice scheduler;
public static void main(String[] args) throws Exception {
    scheduler = Executors.newScheduledThreadPool(5);
    
    scheduler.scheduleAtFixedRate(((
    new Runnable() {
        @Override
        public void run() {
            // DoSomething();
        }
    })), 0, 300, TimeUnit.SECONDS)
    
}
~~~

### 5、任务调度 - Quartz

Quartz这个轻量级的定时任务框架将单机单任务的定时任务做到了极致控制，可惜缺点在于无法进行负载均衡的配置

![image-20230208204541382](https://gitee.com/sky-dog/note/raw/master/img/202302082045557.png)

### 6、分布式定时任务

经过漫长的发展，终于迎来了我们今天课程的重点，分布式的定时任务。

优点有很多：

* 平台化管理
* 分布式部署
* 支持海量数据

他的基本结构大概是如下图所示，以多个定时器对多个调度器进行控制

![image-20230208204824033](https://gitee.com/sky-dog/note/raw/master/img/202302082048173.png)

接下来，我们对这个分布式定时任务做一个简单的定义：

定时任务是指系统为了自动完成特定任务，**实时**、**延时**、**周期性**完成任务调度的过程。

分布式定时任务是把分散的、可靠性差的定时任务纳入统一的平台，并实现集群管理调度和分布式不是的一种定时任务的管理方式。

#### 按触发机制分类：

* 定时任务: 特定事件触发，比如今天11:45:14执行
* 延时任务: 延时出发，比如10s后执行
* 周期任务: 固定周期时间，或固定频率周期调度触发，比如每隔5s或者每天12点执行



#### 分布式定时任务的特点: 

* 自动化: 全自动共完成定时任务的调度和执行
* 平台化: 基于平台化的思维管控一系列的分布式定时任务
* 分布式: 在分布式系统环境下运行任务调度，突破单机定时的性能瓶颈
* 伸缩性: 采用集群方式部署，可以随时按需扩缩容
* 高可用: 单点故障不影响最终任务结果，可以做到故障转移

#### 分布式定时任务的执行方式:

* 单机任务: 随机触发一台机器执行任务，适用于计算量小、并发度低的任务
* 广播任务: 光波导所有机器上执行同一个任务，比如所有机器一起清理日志
* Map任务: 一个任务可以分出多个子任务，每个子任务负责一部分的计算。适用于计算量大，单机无法满足要求的任务
* MapReduce任务: 在Map任务的基础上，还可以对所有子任务的结果做汇总计算，适用于计算量大，并且需要对子任务结果做汇总的任务



#### 业内常见定时任务框架

![image-20230208214350415](https://gitee.com/sky-dog/note/raw/master/img/202302082143552.png)

##### Xxl-job

Xxl-job是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。XXL-JOB 支持分片，简单支持任务依赖，支持子任务依赖，不是跨平台的。

Xxl-job很大一个优势在于**开源且免费**，并且轻量级，开箱即用，操作简单，上手快，企业维护起来成本不高，因而在**中小型公司**中使用非常广泛

##### SchedulerX

分布式任务调度SchedulerX 2.0 是阿里巴巴基于Akka架构自研的新一代分布式任务调度平台，提供定时调度、调度任务编排和分布式批量处理等功能。

SchedulerX 可在阿里云付费使用。他的功能非常强大，**在阿里巴巴内部广泛使用并久经考验。**

##### TCT

分布式任务调度服务(Tencent Cloud Task)是腾讯自主研发的一款高性能、高可靠通用的分布式任务调度中间件，通过指定时间规则严格触发调度任务，保障调度任务的可靠有序执行。该服务支持国际通用的时间表达式、调度任务执行生命周期管理，解决传统定时调度任务单点及并发性能问题。同时，支持任务分片、流程编排复杂调度任务处理能力，覆盖广泛的任务调度应用场景。

**TCT仅在腾讯内部使用，未开源，也未商用。**



### 知识面扩充

> 分布式定时任务 vs 单机定时任务

关系:

* 都可以实现自动化的定时、延时、周期任务调度

差异:

* 分布式定时任务可以支持更大的业务体量
* 分布式定时任务的性能、伸缩性、稳定性更高

> 分布式定时任务 vs 大数据处理引擎

关系:

* 都可以对海量数据做处理
* 性能、伸缩性、稳定性都很高

差异:

* 定时并不是大数据处理引擎要解决的核心问题
* 大数据处理引擎往往致力于将源数据处理成结果数据，分布式定时任务除了能做到这个之外，还可以调用HTTP和RPC服务



## 实现原理

### 核心架构

分布式定时任务核心要解决**触发、调度、执行**三个问题

这里就涉及到三个不同的概念：

* 触发器: Trigger，解析任务，生成触发事件
* 调度器: Scheduler，分配任务，管理任务生命周期
* 执行器: Executor，获取执行任务单元，执行任务逻辑

除此之外，还需要提供一个控制台(Admin)，提供任务管理和干预的功能。

而他们四者之间的关系正如下图所示：

<img src="https://gitee.com/sky-dog/note/raw/master/img/202302091613105.png" alt="image-20230209161350002" style="zoom:66%;" />

#### 数据流

接下来我们看一下分布式定时任务的数据流，也就是分布式定时任务整体上业务流程是如何运行的

如下图所示，用户通过告知控制任务对应的信息，在一定触发规则的基础上，执行了某一段任务代码，然后控制台将用户输入的定时诗句存入任务DB，以此完成任务创建工作

而任务执行，是控制台通过触发器，当触发器满足用户输入的触发规则，就会触发调度器进行定时任务的调度，最后通过执行器来成功完成整个任务的执行。

![image-20230209161734338](https://gitee.com/sky-dog/note/raw/master/img/202302091617526.png)

#### 功能架构

功能架构呢，我们就分别从控制台、触发器、调度器、执行器四个方面，从下图就能很清晰的看见

![image-20230209162246833](https://gitee.com/sky-dog/note/raw/master/img/202302091622981.png)



### 控制台

#### 基本概念

控制台中有多个关键元素，我们接下来一一简单讲解一下

* 任务:  Job，任务元数据
* 任务实例: JobInstance，周期任务会生成多个任务实例
* 任务结果: JobResult，任务实例运行的结果
* 任务历史: JobHistory，用户可以修改任务信息，任务实例对应的任务元数据可以不同，因而使用任务历史存储

下图(E-R图)展示了这些元素之间的关系：

![image-20230209164147765](https://gitee.com/sky-dog/note/raw/master/img/202302091641865.png)

##### 任务

任务元数据(Job)是用户对任务属性定义，包括任务类型调度时机、执行行为等。

<img src="https://gitee.com/sky-dog/note/raw/master/img/202302091644011.png" alt="image-20230209164403921" style="zoom:67%;" />

##### 任务实例

任务实例(JobInstance)是一个确定的Job的一次运行实例

![image-20230209164437216](https://gitee.com/sky-dog/note/raw/master/img/202302091644322.png)

### 触发器

#### 核心职责

给定一系列任务，解析他们的触发规则，在规定的时间点触发任务的调度

#### 设计约束

* 需要支持大量任务
* 需要支持秒级的调度
* 周期任务需要多次执行
* 需要保证秒级扫描的高性能并避免资源浪费

#### 触发器方案

##### 定期扫描+延时消息 (腾讯、字节方案)

定时扫描机器集群部署，通过分布式锁保证只有一台机器在调度

基本流程如下图

<img src="https://gitee.com/sky-dog/note/raw/master/img/202302091653998.png" alt="image-20230209165302910" style="zoom:50%;" />

##### 时间轮 (Quartz方案)

时间轮是一种高效利用县城资源进行批量化调度的一种调度模型。时间轮是一个存储环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表。

其目的是便利任务列表，从中找到当前时间点需触发的任务列表

时间轮模型如下:

<img src="https://gitee.com/sky-dog/note/raw/master/img/202302091654894.png" alt="image-20230209165422824" style="zoom:50%;" />

实现原理如下:

![image-20230209165716528](https://gitee.com/sky-dog/note/raw/master/img/202302091657600.png)![image-20230209165723645](https://gitee.com/sky-dog/note/raw/master/img/202302091657751.png)

![image-20230209165731285](https://gitee.com/sky-dog/note/raw/master/img/202302091657408.png)

![image-20230209165754634](https://gitee.com/sky-dog/note/raw/master/img/202302091657767.png)



#### 高可用

触发器的高可用在分布式定时任务框架中的重要性是显而易见的，一旦任务调度受到影响，或者负责扫描和触发的机器或服务挂了，就会出现不可逆转的灾难

而解决高可用问题的思路有如下几种：

* 存储上，不同国别、业务做资源隔离
* 运行时，不同国别、业务分开执行
* 部署时，采用多机房集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只被触发一次

而高可用的问题又引发出了一系列的问题：

* 只有一个触发器，如果这个触发器故障，整个平台就崩溃了
* 有多个触发器构成集群，可以避免单点故障，弹需要避免同一个任务被多次触发，导致业务紊乱

接下来我们就引入了**锁的概念**

我们可以通过数据库行锁的形式，在触发调度之前，更新数据库中JobInstance的状态，成功抢锁的才会触发调度，但在这种情况下，多台机器频繁竞争数据库锁，节点越多会导致性能越差

或者我们可以使用分布式锁来解决这种问题，在触发调度之前，尝试抢占分布式锁，可使用Redis锁或Zookeeper锁

这样的方法性能较高，有较多公司使用这种方案



### 调度器

#### 资源来源

调度器在定时任务资源来源方面主要分为两个大类，我们分别来介绍

##### 业务系统提供机器资源

使用该方案的公司:

* 美团、阿里、字节等等

优点:

* 任务执行逻辑与业务系统公用同一份资源，利用率更高

缺点:

* 更容易发生定时任务脚本影响在线服务的事故
* 不能由定时任务平台控制扩缩容

##### 定时任务平台提供机器资源

使用该方案的公司:

* 字节跳动等

优点:

* 任务执行逻辑与业务系统提供的在线服务隔离，避免相互影响
* 可以支持优雅地扩缩容

缺点:

* 消耗更多机器资源
* 需要额外为定时任务平台申请接口调用权限，而不能直接继承业务系统的权限

#### 资源调度

##### 节点选择

而调度器选择使用哪个执行器节点进行定时任务的执行也主要分为三种情况：

* 随机节点执行
  * 选择集群中一个可用的执行节点执行调度任务
  * 适用场景：定时对账
* 广播执行
  * 在集群中所有的执行节点分发调度任务并执行
  * 适用场景：批量运维
* 分片执行
  * 按照用户自定义的分片逻辑进行拆分，分发到集群中不同节点并行执行，提高资源利用效率
  * 适用场景：海量日志统计

##### 任务分片

我们可以通过任务分片来提高任务执行的效率和资源的利用率

我们可以通过下图的模型来理解

![image-20230209171502494](https://gitee.com/sky-dog/note/raw/master/img/202302091715600.png)



#### 高级特性

##### 任务编排

大多数分布式定时任务框架都支持使用有向无环图DAG (Directed Acyclic Graph)进行可视化的任务编排

就如下图所示，是一种编排的例子：

![image-20230209171747846](https://gitee.com/sky-dog/note/raw/master/img/202302091717930.png)

##### 故障转移

故障转移是为了确保部分执行单元任务失败时，任务最终成功

分片任务基于一致性hash策略分发任务，当某个Executor异常时，调度器会将任务分发到其他的Executor

![image-20230209171903663](https://gitee.com/sky-dog/note/raw/master/img/202302091719760.png)



#### 高可用

调度器可以做到集群部署，做到完全的无状态，依靠消息队列的重试机制保障任务一定会被调度

![image-20230209171953617](https://gitee.com/sky-dog/note/raw/master/img/202302091719706.png)

### 执行器

执行器的基本框架如下图，基于注册中心，执行器可以做到弹性进行扩缩容

![image-20230209172343622](https://gitee.com/sky-dog/note/raw/master/img/202302091723727.png)









